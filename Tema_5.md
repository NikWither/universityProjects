# Тема 5. Функции и стандартные модули/библиотеки
Отчет по Теме №5 выполнил:
- Цаплин Всеволод Ильич
- АИС-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | - |
| Задание 6 | + | - |
| Задание 7 | + | - |
| Задание 8 | + | - |
| Задание 9 | + | - |
| Задание 10 | + | - |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Друзья предложили вам поиграть в игру “найди отличия и убери
### повторения (версия для программистов)”. Суть игры состоит в том, что
### на вход программы поступает два множества, а ваша задача вывести
### все элементы первого, которых нет во втором. А вы как раз недавно
### прошли множества и знаете их возможности, поэтому это не составит
### для вас труда.

```python
set_1 = {'White', 'Black', 'Red', 'Pink'}
set_2 = {'Red', 'Green', 'Blue', 'Red'}

print('1', set_1 - set_2)

set_1 = {'White', 'Black', 'Red', 'Pink', 'Black', 'White'}
set_2 = {'Red', 'Green', 'Blue', 'Red'}

print('2', set_1 - set_2)

set_1 = {'White', 'Black', 'Red', 'Pink', 'Red', 'White'}
set_2 = {'Red', 'Green', 'Red', 'Red', 'Red'}

print('3', set_1 - set_2)
```

### Результат.

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab1.jpg)

## Выводы

Со словарями можно проводить арифметические операции 

## Лабораторная работа №2
### Напишите две одинаковые программы, только одна будет использовать set(), а вторая frozenset() и попробуйте к исходному множеству
### добавить несколько элементов, например, через цикл.

```python
a = set('abcdefg')
print(a)
for i in range(1, 5):
    a.add(i)
print(a)
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab2.jpg)

### Выводы

frozenset() - это словарь константа, который нельзя изменять (добавлять, удалять, редактировать). 

## Лабораторная работа №3
### На вход в программу поступает список (минимальной длиной 2 символа). Напишите программу, которая будет менять первый и последний элемент списка

```python
def replace(input_list):
    memory = input_list[0]
    input_list[0] = input_list[-1]
    input_list[-1] = memory

    return input_list

print(replace([1, 2, 3, 4, 5]))
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab3.jpg)

  
## Лабораторная работа №4
### На вход в программу поступает список (минимальной длиной 10 символов). Напишите программу, которая выводит элементы с индексами от 2 до 6. В программе необходимо использовать “срез”.

```python
a = [12, 54, 32, 57, 843, 2346, 765, 75, 25, 234, 756, 23]
print(a[2:6])
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab4.jpg)


## Лабораторная работа №5
### Иван задумался о поиске «бесполезного» числа, полученного из списка. Суть поиска в следующем: он берет произвольный список чисел, находит самое большое из них, а затем делит его на длину списка. Студент пока не придумал, где может пригодиться подобное
### значение, но ищет у вас помощи в реализации такой функции useless().

```python
def useless(lst):
    return max(lst) / len(lst)

print(useless([3, 5, 7, 3, 33]))
print(useless([-12.5, 54, 77.3, 0, -36, 98.2, -63, 21.7, 47, -89.6]))
print(useless([-25.8, 86, 12.5, -56, 73.2, 0, 43, -91.5, 65.9, -7]))
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab5.jpg)


## Лабораторная работа №6
### Ребята не могут определится каким супергероем они хотят стать. У них есть случайно составленный список супергероев, и вы должны определить кто из ребят будет каким супергероем. Необходимо
### использовать разделение списков.

```python
superheroes = ['superman', 'spiderman', 'batman']

nikolay, vasiliy, ivan = superheroes

print('Николай - ', nikolay)
print('Василий - ', vasiliy)
print('Иван - ', ivan)

```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab6.jpg)

### Выводы

Значения переменным можно задать следующим образом. (есть название у этого всего, не помню, как называется)

## Лабораторная работа №7
### Вовочка, насмотревшись передачи “Слабое звено” решил написать программу, которая также будет находить самое слабое звено (минимальный элемент) и удалять его, только делать он это хочет не с
### людьми, а со списком. Помогите Вовочке с реализацией программы.

```python
a = [-25.8, 86, 12.5, -56, 73.2, 0, 43, -91.5, 65.9, -7]
a.sort()
print('Отсортированный список:\n', a)
a.pop(0)
print('Отсортированный список без наименьшего элемента:\n', a)
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab7.jpg)


## Лабораторная работа №8
### Михаил решил создать большой n-мерный список, для этого он случайным образом создал несколько списков, состоящих минимум из 3, а максимум из 10 элементов и поместил их в один большой список.
### Он также как и Иван не знает зачем ему это сейчас нужно, но надеется на то, что это пригодится ему в будущем.

```python
from random import randint

def list_maker():
    a = [randint(1, 100) * randint(3, 10)]
    return a

if __name__ == '__main__':
    result = []
    for i in range(randint(1, 5)):
        result.append(list_maker())

    print(result)
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab8.jpg)

## Лабораторная работа №9
### Вы работаете в ресторане и отвечает за статистику покупок, ваша задача сравнить между собой заказы покупателей, которые указаны в разном порядке. Реализуйте функцию superset(), которая принимает 2
### множества. Результат работы функции: вывод в консоль одного из сообщений в зависимости от ситуации:
### 1 - «Супермножество не обнаружено»
### 2 – «Объект {X} является чистым супермножеством»
### 3 – «Множества равны»

```python
def superset(set_1, set_2):
    if set_1 > set_2:
        print(f'Объект {set_1} является чистым супермножеством')
    elif set_1 == set_2:
        print(f'Множества равны')
    elif set_1 < set_2:
        print(f'Объект {set_2} является чистым супермножеством')
    else:
        print('Супермножество не обнаружено')

if __name__ == '__main__':
    superset({1, 8, 3, 5}, {3, 5})
    superset({1, 8, 3, 5}, {5, 3, 8, 1})
    superset({3, 5}, {5, 3, 8, 1})
    superset({90, 100}, {3, 5})

```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab9.jpg)


## Лабораторная работа №10
### Предположим, что вам нужно разобрать стопку бумаг, но нужно начать работу с нижней, “переверните стопку”. Вам дан произвольный список. Представьте его в обратном порядке. Программа должна
### занимать не более двух строк в редакторе кода.
```python
my_list = [2, 5, 8, 3]
print(my_list[::-1])
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/lab10.jpg)

## Самостоятельная работа №1
### Ресторан на предприятии ведет учет посещений за неделю при помощи
### кода работника. У них есть список со всеми посещениями за неделю.
### Ваша задача почитать:
### • Сколько было выдано чеков
### • Сколько разных людей посетило ресторан
### • Какой работник посетил ресторан больше всех раз
### Список выданных чеков за неделю:
### [8734, 2345, 8201, 6621, 9999, 1234, 5678, 8201, 8888, 4321, 3365,
### 1478, 9865, 5555, 7777, 9998, 1111, 2222, 3333, 4444, 5556, 6666,
### 5410, 7778, 8889, 4445, 1439, 9604, 8201, 3365, 7502, 3016, 4928,
### 5837, 8201, 2643, 5017, 9682, 8530, 3250, 7193, 9051, 4506, 1987,
### 3365, 5410, 7168, 7777, 9865, 5678, 8201, 4445, 3016, 4506, 4506]
### Результатом выполнения задачи будет: листинг кода, и вывод в
### консоль, в котором будет указана вся необходимая информация.
```python
guest_list = [8734, 2345, 8201, 6621, 9999, 1234, 5678, 8201, 8888, 4321, 3365, 1478, 9865, 5555,
         7777, 9998, 1111, 2222, 3333, 4444, 5556, 6666, 5410, 7778, 8889, 4445, 1439, 9604,
         8201, 3365, 7502, 3016, 4928, 5837, 8201, 2643, 5017, 9682, 8530, 3250, 7193, 9051,
         4506, 1987, 3365, 5410, 7168, 7777, 9865, 5678, 8201, 4445, 3016, 4506, 4506]

def getCount(checkList):
    return len(checkList)

def getCountOfGuest(checkList):
    return len(set(checkList))

def getFavouriteGuest(checkList):
    return max(checkList, key=checkList.count)

print(f'Количество чеков: {getCount(guest_list)}\n'
      f'Число уникальных гостей: {getCountOfGuest(guest_list)}\n'
      f'Самый частый гость: {getFavouriteGuest(guest_list)}')
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/cp1.jpg)

### Выводы

Для решения поставленных задач создадим три функции.
Функция getCount() - принимает массив значений и возвращает с помощью функции len количество элементов данного массива.
Функция getCountOfGuest() - принимает массив значений и создает из него множество (тем самым удаляя дубликаты), а затем, воспользовавшись функцией
len, берем количество элементов этого множества. Возвращаем ответ
Функция getFavouriteGuest() - принимает массив значений и, с помощью функции max, находим номер гостя, который встречается чаще всего по ключу 
количество повторений числа.
 
## Самостоятельная работа №2
### На физкультуре студенты сдавали бег, у преподавателя физкультуры
### есть список всех результатов, ему нужно узнать
### • Три лучшие результата
### • Три худшие результата
### • Все результаты начиная с 10
### Ваша задача помочь ему в этом.
### Список результатов бега:
### [10.2, 14.8, 19.3, 22.7, 12.5, 33.1, 38.9, 21.6, 26.4, 17.1, 30.2, 35.7, 16.9,
### 27.8, 24.5, 16.3, 18.7, 31.9, 12.9, 37.4]
### Результатом выполнения задачи будет: листинг кода, и вывод в консоль, в котором будет указана вся необходимая информация.

```python
results = [10.2, 14.8, 19.3, 22.7, 12.5, 33.1, 38.9, 21.6, 26.4, 17.1, 30.2, 35.7, 16.9,
           27.8, 24.5, 16.3, 18.7, 31.9, 12.9, 37.4]

results.sort()

def getThreeBest(results_list):
    return results_list[-3:]

def getThreeWorst(results_list):
    return results_list[:3]

def getAllFromTen(results_list):
    return results_list


print(
    f'Топ-3 лучших результата: {getThreeBest(results)}\n'
    f'Топ-3 худших результата: {getThreeWorst(results)}\n'
    f'Все результаты начиная с 10-ти: {getAllFromTen(results)}'
)
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/cp2.jpg)

### Выводы

Для решения поставленных задач создадим три функции, а также применим сортировку к массиву results, чтобы все значения отсортировались в возрастающем порядке
Функция getThreeBest() - принимает массив значений и возвращает с помощью среза 3 последних элемента, так как массив отсортирован, то мы
возвращаем сразу же 3 самых лучших результата (последний в массиве)
Аналогично работает функция getThreeWorst(), которая возвращает 3 первых элемента в массиве
Функция getAllFromTen() просто возвращает этот список, так как все результаты начинаются с 10
  
## Самостоятельная работа №3
### Преподаватель по математике придумал странную задачку. У вас есть три списка с элементами, каждый элемент которых – длина стороны треугольника, ваша задача найти площади двух треугольников,
### составленные из максимальных и минимальных элементов полученных списков. Результатом выполнения задачи будет: листинг кода, и вывод в консоль, в котором будут указаны два этих значения.
### Три списка:
### one = [12, 25, 3, 48, 71]
### two = [5, 18, 40, 62, 98]
### three = [4, 21, 37, 56, 84]

```python
one = [12, 25, 3, 48, 71]
two = [5, 18, 40, 62, 98]
three = [4, 21, 37, 56, 84]

def giveMaxSide(array):
    return max(array)

def giveMinSide(array):
    return min(array)

def findTrinagleArea(a, b, c):
    p = (a + b + c) / 2
    s = (p * (p - a) * (p - b) * (p - c))**0.5
    return s

aMax, bMax, cMax = giveMaxSide(one), giveMaxSide(two), giveMaxSide(three)
print("Максимальная площадь треугольника - ", findTrinagleArea(aMax, bMax, cMax))

aMin, bMin, cMin = giveMinSide(one), giveMinSide(two), giveMinSide(three)
print("Минимальная площадь треугольника - ", findTrinagleArea(aMin, bMin, cMin))
```

  ### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/cp3.jpg)

### Выводы

Создадим две функции giveMinSide() & giveMinSide(), каждая из которых принимает массив, а возвращает минимальный и максимальный элемент из него соответственно.
Так как у треугольника 3 стороны, создадим 2 пары по 3 переменных для каждого треугольника aMax, bMax, cMax и aMin, bMin, cMin, затем, воспользовшись
функциями, созданными выше - в каждую переменную положим значения из массива. Далее вызываем функцию findTrinagleArea(), которая находится
площадь треугольника с помощью формулы Герона, которую вспоминали в прошлом блоке.
  
## Самостоятельная работа №4
### Никто не любит получать плохие оценки, поэтому Борис решил это исправить. Допустим, что все оценки студента за семестр хранятся в одном списке. Ваша задача удалить из этого списка все двойки, а все
### тройки заменить на четверки. 
### Списки оценок (проверить работу программы на всех трех вариантах):
### [2, 3, 4, 5, 3, 4, 5, 2, 2, 5, 3, 4, 3, 5, 4]
### [4, 2, 3, 5, 3, 5, 4, 2, 2, 5, 4, 3, 5, 3, 4]
### [5, 4, 3, 3, 4, 3, 3, 5, 5, 3, 3, 3, 3, 4, 4]
### Результатом выполнения задачи будет: листинг кода, и вывод в консоль, в котором будут три обновленных массива.
  
```python
one = [2, 3, 4, 5, 3, 4, 5, 2, 2, 5, 3, 4, 3, 5, 4]
two = [4, 2, 3, 5, 3, 5, 4, 2, 2, 5, 4, 3, 5, 3, 4]
three = [5, 4, 3, 3, 4, 3, 3, 5, 5, 3, 3, 3, 3, 4, 4]

def deleteBadMark(arrayMark):
    while 2 in arrayMark:
        arrayMark.remove(2)
    return arrayMark

def replaceBadMark(arrayMark):
    newMarks = (' '.join(str(el) for el in arrayMark))
    newMarks = newMarks.replace('3', '4')
    return [int(x) for x in newMarks.split()]

def helpForBoris(arrayMark):
    arrayMark = deleteBadMark(arrayMark)
    arrayMark = replaceBadMark(arrayMark)
    return arrayMark

print(f"Старые оценки:\n{one}\nНовые оценки:\n{helpForBoris(one)}")
print(f"Старые оценки:\n{two}\nНовые оценки:\n{helpForBoris(two)}")
print(f"Старые оценки:\n{three}\nНовые оценки:\n{helpForBoris(three)}")
```

### Результат

![Меню](https://github.com/NikWither/universityProjects/blob/Тема_5/pic/cp4.jpg)

### Выводы

Каждая функция будет решать свою задачу. Создадим функцию deleteBadMark() которая принимает массив значений и, пока не удалит все двойки в массиве (цикл вайл),
не успокоится (после того, как успокоится, вернет массив без двоек)
Далее функция replaceBadMark(), которая, судя по названию, заменяет плохие оценки. Вопрос кстати, что такое badMark? Ну, в нашем случае это 
тройки! Ну, метод replace() может работать только со строками, поэтому с помощью метода join (который, кстати, принимает аргумент в самом начале),
склеиваем массив в одну большую строчку. Затем к строчке уже применяем replace, который заменяет 3 на 4, а затем с помощью популярной среди
питонистов функцией split (которая по умолчанию всегда переводит любой тип данных в массив), создаем из нашей строчки массив, который сразу
же возвращаем Вововчке балбесу.. А, там Борис, ну ладно. Далее создал общую функцию helpForBoris, которая уже управляет всеми функциями, описанными
выше.. вау, да это же использование паттерна Фассад?? Ну, типо того, почти, не просто так же на программиста учусь, иногда можно и код хороший написать
как этот вывод. Ну, данная функция просто вызывает две другие функции. Потом просто это всё печатаем и Борис может спокойно заниматься своими
делами, поиграть в комп, погулять с друзьями, попрыгать по гаражам, побросать снежки в проезжающие автомобили и так далее.. Пока не получит по 
шапке от родителей за такие трюки с оценками.
  
## Самостоятельная работа №5

```python
```

### Результат

### Выводы

## Общие выводы по теме

В языке программирования Python есть много разных типов данных (списки, множества), каждые из которых отличаются друг от друга, например:
*Списки (list) - это упорядоченные коллекции элементов, которые могут содержать любые типы данных. Списки изменяемы, позволяют добавлять, удалять и изменять элементы. Я их часто называл массивами, ну потому что я не питонист

*Множества (sets) - множества представляют собой коллекции уникальных элементов, которые не упорядочены. Можно выполнять операции над множествами, такие как объединение, пересечение, разность и другие фокусы.

Вообще в силу того, что питон не строготипизированный яп, а имеет динамическую типизацию, то можно вытворять много приколов, трюков и фокусов с 
типами данных, сделать из списка строку, а затем конвертировать её обратно? Да на здоровье.. Очень полезно, иногда бывает, но очень опасно.
Было здорово решать задачу номер 4 (ср4), где была необходимость из списка сделать строку, применить метод replace, а затем конвертировать это
всё обратно в список - интересно. Какой-нибудь C# не разрешил вытворить такое, а питон вот, пожалуйста. 

Также, это, конечно, здесь не заметно, но использовал функциональный подход к решению каждой задачи, поэтому масштабируемость или доп. условия несильно бы
изменили мой код. Модуль классный.
